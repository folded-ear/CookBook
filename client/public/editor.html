<!doctype html>
<!--suppress HtmlUnknownTarget -->
<html lang="en">
<head>
    <title>Demo</title>
    <style type="text/css">
        #request {
            float: right;
        }
        span.amount {
            display: inline-block;
            border-bottom: 1px solid red;
            background-color: #fee;
        }
        span.unit {
            display: inline-block;
            border-bottom: 1px solid blue;
            background-color: #eef;
        }
        span.item {
            display: inline-block;
            border-bottom: 1px solid green;
            background-color: #efe;
        }
    </style>
</head>
<body>
<div id="editor" contenteditable="true"><span class="amount">1.5</span> <span class="unit">cup</span> fl</div>
<pre id="request"></pre>
<pre id="parse"></pre>
<script type="text/javascript">
    // based on https://codepen.io/neoux/pen/OVzMor
    function getCaretCharacterOffsetWithin(element) {
        var caretOffset = 0;
        var doc = element.ownerDocument || element.document;
        var win = doc.defaultView || doc.parentWindow;
        var sel;
        if (typeof win.getSelection != "undefined") {
            sel = win.getSelection();
            if (sel.rangeCount > 0) {
                var range = win.getSelection().getRangeAt(0);
                var preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(element);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                caretOffset = preCaretRange.toString().length;
            }
        } else if ((sel = doc.selection) && sel.type !== "Control") {
            var textRange = sel.createRange();
            var preCaretTextRange = doc.body.createTextRange();
            preCaretTextRange.moveToElementText(element);
            preCaretTextRange.setEndPoint("EndToEnd", textRange);
            caretOffset = preCaretTextRange.text.length;
        }
        return caretOffset;
    }

    // from src/util/debounce.js
    const debounce = (fn, delay = 100) => {
        let timeout = null
        return (...args) => {
            if (timeout != null) {
                clearTimeout(timeout)
            }
            timeout = setTimeout(() => {
                timeout = null
                fn(...args)
            }, delay)
        }
    }

    // the "database"
    UNITS = "cup,tsp,Tbsp,teaspoon,Tablespoon,ounce,oz".split(",");
    ITEMS = "bouillon cube,flour,eggs,flip-flops,flippers,salt,sugar,water,milk,cucumber".split(",");

    // the parser "API"
    const parseThatShit = (query, caret, callback) => {
        if (query == null || query.trim().length === 0) return;
        if (query.trim() !== query) return;
        const ranges = [];
        const suggestions = [];
        const words = query.split(" ");
        let wIdx = 0;
        let amount = null;
        let unit = null;
        const c = words[wIdx].charAt(0);
        if ((c >= "0" && c <= "9") || c === ".") {
            amount = parseFloat(words[wIdx]);
            wIdx += 1;
            if (!isNaN(amount)) {
                ranges.push({
                    start: 0,
                    end: words[wIdx].length,
                    type: "amount",
                });
            }
        }
        for (let i = wIdx; i < words.length; i++) {
            const w = words[i];
            console.log("check", w)
            const sow = words.slice(0, i)
                .reduce((n, w) => n + w.length, i);
            if (amount != null && unit == null) {
                // see about a unit
                let u = UNITS.find(u => u === w);
                if (u != null) {
                    // exact match!
                    unit = u;
                    ranges.push({
                        start: sow,
                        end: sow + u.length,
                        type: "unit",
                    });
                    console.log("exact match on", u)
                    continue;
                }
                const partials = UNITS.filter(u => u.indexOf(w) === 0)
                partials.forEach(u => {
                    unit = u; // not really true, but whatever
                    suggestions.push({
                        option: u,
                        type: "unit",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + u.length,
                        },
                    });
                });
            }
            let it = ITEMS.find(it => it === w);
            if (it != null) {
                // exact match!
                ranges.push({
                    start: sow,
                    end: sow + it.length,
                    type: "item",
                });
                console.log("exact match on", it)
                continue;
            }
            ITEMS.filter(it => it.indexOf(w) === 0)
                .forEach(it => {
                    console.log("prefix match on", it)
                    suggestions.push({
                        option: it,
                        type: "item",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + it.length,
                        },
                    })
                });
            ITEMS.filter(it => it.indexOf(w) !== 0 && it.indexOf(w) > 0)
                .forEach(it => {
                    console.log("substring match on", it)
                    const idx = it.indexOf(w)
                    suggestions.push({
                        option: {
                            name: it,
                            start: idx,
                            end: idx + w.length,
                        },
                        type: "item",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + it.length,
                        },
                    })
                });
        }
        const response = {
            query,
            caret,
            ranges,
            suggestions,
        }
        setTimeout(() => callback(response), 150 + Math.random() * 300);
    };

    E = document.getElementById("editor");
    R = document.getElementById("request");
    P = document.getElementById("parse");
    handleUserInteraction = debounce(e => {
        console.log(e);
        const query = E.innerText;
        const caret = getCaretCharacterOffsetWithin(E);
        R.innerText = JSON.stringify({query, caret}, null, 3);
        console.log("  ", query, caret);
        parseThatShit(query, caret, r => {
            if (r.query !== query || r.caret !== caret) return;
            console.log("PARSE", r);
            P.innerText = JSON.stringify(r, null, 3);
        });
    }, 150);
    E.addEventListener("input", handleUserInteraction);
    E.addEventListener("keyup", handleUserInteraction);
    E.addEventListener("mouseup", handleUserInteraction);
</script>
</body>
</html>
