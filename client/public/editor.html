<!doctype html>
<!--suppress HtmlUnknownTarget -->
<html lang="en">
<head>
    <title>Demo</title>
    <style type="text/css">
        #request {
            float: right;
        }
        .amount {
            border-bottom: 1px solid red;
            background-color: #fee;
        }
        .unit {
            border-bottom: 1px solid blue;
            background-color: #eef;
        }
        .item {
            border-bottom: 1px solid green;
            background-color: #efe;
        }
    </style>
</head>
<body>
<div id="editor" contenteditable="true">1.5 cu fl</div>
<ul id="autocomplete"></ul>
<pre id="request"></pre>
<pre id="parse"></pre>
<script type="text/javascript">
    // from https://github.com/JetBrains/ring-ui/blob/master/components/global/dom.js
    function isMounted(node) {
        if (node === document) {
            return true;
        }

        return node instanceof Node && document.documentElement.contains(node.parentNode);
    }

    const rectStub = {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};

    function getRect(node) {
        if (node instanceof Range || isMounted(node)) {
            const {top, right, bottom, left, width, height} = node.getBoundingClientRect();
            return {top, right, bottom, left, width, height};
        } else {
            return Object.assign({}, rectStub);
        }
    }

    // based on https://github.com/JetBrains/ring-ui/blob/master/components/caret/caret.js
    class Caret {
        /**
         * Line endings RegExp
         * @type {RegExp}
         */
        static returnRE = /\r/g;

        /**
         * Line endings normalizer
         * Borrowed from jQuery
         * @see https://github.com/jquery/jquery/blob/master/src/attributes/val.js
         * @param value {*}
         * @return {*}
         */
        static normalizeNewlines(value) {
            return typeof value === 'string' ? value.replace(
                this.returnRE,
                '',
            ) : value;
        }

        constructor(target) {
            this.target = target;
        }

        isContentEditable() {
            return this.target.contentEditable === 'true';
        }

        /**
         * Set focus on target if possible
         */
        focus() {
            if (!document.activeElement || document.activeElement !== this.target) {
                this.target.focus();
            }
        }

        /**
         * Get caret position index
         * @param {Object} [params]
         * @param {boolean} params.avoidFocus
         * @return {number}
         */
        getPosition(params = {}) {
            if (this.isContentEditable()) {
                if (!params.avoidFocus) {
                    this.focus();
                }

                const selection = window.getSelection();

                if (!selection.rangeCount) {
                    return 0;
                }

                const range1 = selection.getRangeAt(0);

                if (range1.startOffset !== range1.endOffset) {
                    return -1;
                }

                const range2 = range1.cloneRange();

                range2.selectNodeContents(this.target);
                range2.setEnd(range1.endContainer, range1.endOffset);

                return range2.toString().length;
            }

            if (this.target.selectionStart !== this.target.selectionEnd) {
                return -1;
            }

            return this.target.selectionStart;
        }

        /**
         * Set caret position index
         * @param  {number} position
         * @return {number}
         */
        setPosition(position) {
            const isContentEditable = this.isContentEditable();
            let correctedPosition;

            if (position === -1) {
                const value = isContentEditable
                    ? this.target.textContent
                    : this.constructor.normalizeNewlines(this.target.value);
                correctedPosition = value.length;
            } else {
                correctedPosition = position;
            }

            if (isContentEditable) {
                this.focus();

                try {
                    window.getSelection()
                        .collapse(
                            this.target.firstChild || this.target,
                            correctedPosition,
                        );
                } catch (e) {
                    // Do nothing
                }

            } else {
                this.target.setSelectionRange(
                    correctedPosition,
                    correctedPosition,
                );
            }

            return correctedPosition;
        }

        /**
         * Get caret position in pixels
         * @return {number}
         */
        getOffset() {
            let offset = 0;
            let range;

            try {
                // Both statements may throw
                range = window.getSelection().getRangeAt(0).cloneRange();
                range.setStart(range.startContainer, range.startOffset - 1);
            } catch (e) {
                return offset;
            }

            if (range && range.endOffset !== 0 && range.toString() !== '') {
                offset =
                    getRect(range).right -
                    getRect(this.target).left -
                    (range.startContainer.offsetLeft || 0);
            }

            return offset;
        }
    }

    // from src/util/debounce.js
    const debounce = (fn, delay = 100) => {
        let timeout = null
        return (...args) => {
            if (timeout != null) {
                clearTimeout(timeout)
            }
            timeout = setTimeout(() => {
                timeout = null
                fn(...args)
            }, delay)
        }
    }

    // the "database"
    UNITS = "cup,tsp,Tbsp,teaspoon,Tablespoon,ounce,oz".split(",");
    ITEMS = "bouillon cube,flour,eggs,flip-flops,flippers,salt,sugar,water,milk,cucumber".split(",");
    NUM_RE = /^[0-9]+(\.[0-9]*)?$/;

    // the parser "API"
    const parseThatShit = (query, caret, callback) => {
        if (query == null || query.trim().length === 0) return callback();
        if (query.trim() !== query) return callback();
        const ranges = [];
        const suggestions = [];
        const words = query.split(" ");
        let wIdx = 0;
        let amount = null;
        let unit = null;
        if (NUM_RE.test(words[wIdx])) {
            amount = parseFloat(words[wIdx]);
            if (!isNaN(amount)) {
                ranges.push({
                    start: 0,
                    end: words[wIdx].length,
                    type: "amount",
                });
            }
            wIdx += 1;
        }
        for (let i = wIdx; i < words.length; i++) {
            const w = words[i];
            const sow = words.slice(0, i)
                .reduce((n, w) => n + w.length, i);
            if (amount != null && unit == null) {
                // see about a unit
                let u = UNITS.find(u => u === w);
                if (u != null) {
                    // exact match!
                    unit = u;
                    ranges.push({
                        start: sow,
                        end: sow + u.length,
                        type: "unit",
                    });
                    continue;
                }
                const partials = UNITS.filter(u => u.indexOf(w) === 0)
                partials.forEach(u => {
                    unit = u; // not really true, but whatever
                    suggestions.push({
                        option: u,
                        type: "unit",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + u.length,
                        },
                    });
                });
            }
            let it = ITEMS.find(it => it === w);
            if (it != null) {
                // exact match!
                ranges.push({
                    start: sow,
                    end: sow + it.length,
                    type: "item",
                });
                continue;
            }
            ITEMS.filter(it => it.indexOf(w) === 0)
                .forEach(it => {
                    suggestions.push({
                        option: it,
                        type: "item",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + it.length,
                        },
                    })
                });
            ITEMS.filter(it => it.indexOf(w) !== 0 && it.indexOf(w) > 0)
                .forEach(it => {
                    const idx = it.indexOf(w)
                    suggestions.push({
                        option: {
                            name: it,
                            start: idx,
                            end: idx + w.length,
                        },
                        type: "item",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + it.length,
                        },
                    })
                });
        }
        const response = {
            query,
            caret,
            ranges,
            suggestions,
        }
        setTimeout(() => callback(response), 150 + Math.random() * 300);
    };

    E = document.getElementById("editor");
    A = document.getElementById("autocomplete");
    R = document.getElementById("request");
    P = document.getElementById("parse");
    const empty = node => {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    };
    (function () {
        let query = "";
        let caret = -1;
        reparse = debounce(() => {
            R.innerText = JSON.stringify({query, caret}, null, 3);
            parseThatShit(query, caret, r => {
                empty(A);
                P.innerText = JSON.stringify(r, null, 3);
                if (r == null || r.query !== query || r.caret !== caret) return;
                // now update!
                let pos = 0
                let segments = []
                const addChars = (cs, cls) => {
                    const prefix = cls == null
                        ? `<span>`
                        : `<span class="${cls}">`;
                    Array.from(cs).forEach(c =>
                        segments.push(prefix + c + `</span>`));
                }
                r.ranges.sort((a, b) => a.start - b.start)
                    .map((it, i, rs) => {
                        if (i === 0) return it;
                        const prev = rs[i - 1];
                        if (it.start >= prev.end) return it;
                        return {
                            ...it,
                            start: prev.end, // no overlaps!
                        }
                    })
                    .forEach(({start, end, type}) => {
                        if (start > pos) {
                            addChars(query.substring(pos, start))
                        }
                        addChars(query.substring(start, end), type)
                        pos = end
                    });
                if (pos < query.length) {
                    addChars(query.substring(pos))
                }
                const c = new Caret(E);
                const p = c.getPosition();
                const o = c.getOffset();
                E.innerHTML = `<span>${segments.join("")}</span>`;
                console.log("caret a", caret, p, c.getPosition(), o, c.getOffset())
                c.setPosition(caret);
                setTimeout(() =>
                    console.log("      b", caret, p, c.getPosition(), o, c.getOffset()))
                // and auto-complete!
                r.suggestions
                    .map(s => {
                        const text = typeof s.option === "string"
                            ? s.option
                            : s.option.name;
                        const li = document.createElement("li");
                        li.innerText = text;
                        li.className = s.type;
                        li.addEventListener("click", e => {
                            query = E.innerText.substring(0, s.accept.start)
                                + text
                            + E.innerText.substring(s.accept.end);
                            caret = s.accept.caret;
                            reparse();
                        });
                        A.appendChild(li);
                    })
            });
        }, 150)
        handleUserInteraction = e => {
            const q = E.innerText.replace(/\u00A0/g, " ");
            const c = new Caret(E).getPosition();
            if (caret === c && query === q) return;
            query = q;
            caret = c;
            reparse();
        };
        E.addEventListener("input", handleUserInteraction);
        E.addEventListener("keyup", handleUserInteraction);
        E.addEventListener("mouseup", handleUserInteraction);
    })();
</script>
<pre style="padding:5px 10px;background-color:#f7f7f7;border:1px solid #ddd;border-radius:0.5em;width:fit-content;">
# UI Components

-   a single-line editor (an INPUT replacement)
    -   indicate if the ref is parsed or not
    -   hint at the item name
    -   be unobtrusive when not focused, but still indicate when attention is
        needed
-   a "list of editors" component w/ some sophistication for operating on a
    vertical list of editor components (a TEXTAREA replacement).
    -   pasting a multi-line string into one editor should split the string
        up and create N-1 new editors below the target for each of the
        second and subsequent lines pasted.
    -   up/down arrows should move to the prev/next editor (if there is one)
        AND maintain the caret position in the line.

# UI Changes

-   RecipeForm should use the "list of editors" above instead of TEXTAREA
    for accepting raw ingredients
-   AddRecipe and EditRecipe shouldn't allow the user to submit until all refs
    are parsed.
-   the "parse" button on ViewRecipe should cease to exist, and corrections
    will be made by editing the recipe, and using the editor(s) there. though
    there should still be clear visual indication that attention is needed.
-   "has unparsed ingredient(s)" should be a more flagrant visual cue in the
    UI, rather than only you open a recipe for viewing. E.g., decorate recipe
    title everywhere.

# DraftRecipeStore

-   no more `rawIngredients` string; rather the ingredients themselves will
    be edited directly. This means synthesizing a "parse result" for the
    current state of the ref (NOT how the parser would parse the raw).

# API Endpoints

-   `/api/recipe/_action` type `PARSE_RAW_REF` w/ parameterized with the raw
    string, and returning a parse result. Some additional parameterization
    of what type(s) of items should be name-matched will be needed too.

# Parser

To back the endpoint above accepting a raw string and caret position, and
returning a result containing two lists:

-   ranges (start/end codepoints, and "type")
-   completions (name, "type", and how to munge the string if accepted)

Raw strings are assumed (for now) to match this psuedo-grammar:

    ( amount units? )? prep? name prep? ("," prep)

The amount may be several words (e.g., "1 and 1/2"), but will always be at the
start of the line, and be identified by either a numeric digit, a vulgar
fraction, or one of a handful of "number words" (e.g., "one" or "half").

The units are only looked for if an amount is found, and may also be multiple
words (e.g., "fluid ounces"). They're never identifiable, other than by a "good
match" against the Unit repository.

The name identifies the repository Entity being referenced, and is the fuzziest
part of the whole shebang. Like units, names may be multiple words, and there
may be "prep" text around the name in a whole host of different configurations.
In addition, there may be multiple potential repositories to match into (e.g.,
when adding recipe ingredients, names can match `PantryItem` or `Recipe`).

# Repositories

Each repository needs to have a `fuzzyMatch(String guess)` (or something)
method which returns a `List` of matches, ordered by relevance. Each match
should have the candidate entity and some sort of "confidence rating" for the
match (from 0-1). These need to be _fast_, as they're going to get called a
lot.

-   Unit
-   PantryItem
-   Recipe
</pre>
</body>
</html>
