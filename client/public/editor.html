<!doctype html>
<!--suppress HtmlUnknownTarget -->
<html lang="en">
<head>
    <title>Demo</title>
    <style type="text/css">
        #request {
            float: right;
        }
        .amount {
            border-bottom: 1px solid red;
            background-color: #fee;
        }
        .unit {
            border-bottom: 1px solid blue;
            background-color: #eef;
        }
        .item {
            border-bottom: 1px solid green;
            background-color: #efe;
        }
    </style>
</head>
<body>
<div id="editor" contenteditable="true">1.5 cu fl</div>
<ul id="autocomplete"></ul>
<pre id="request"></pre>
<pre id="parse"></pre>
<script type="text/javascript">
    // based on https://codepen.io/neoux/pen/OVzMor
    function getCaretCharacterOffsetWithin(element) {
        var caretOffset = 0;
        var doc = element.ownerDocument || element.document;
        var win = doc.defaultView || doc.parentWindow;
        var sel;
        if (typeof win.getSelection != "undefined") {
            sel = win.getSelection();
            if (sel.rangeCount > 0) {
                var range = win.getSelection().getRangeAt(0);
                var preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(element);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                caretOffset = preCaretRange.toString().length;
            }
        } else if ((sel = doc.selection) && sel.type !== "Control") {
            var textRange = sel.createRange();
            var preCaretTextRange = doc.body.createTextRange();
            preCaretTextRange.moveToElementText(element);
            preCaretTextRange.setEndPoint("EndToEnd", textRange);
            caretOffset = preCaretTextRange.text.length;
        }
        return caretOffset;
    }

    // from src/util/debounce.js
    const debounce = (fn, delay = 100) => {
        let timeout = null
        return (...args) => {
            if (timeout != null) {
                clearTimeout(timeout)
            }
            timeout = setTimeout(() => {
                timeout = null
                fn(...args)
            }, delay)
        }
    }

    // the "database"
    UNITS = "cup,tsp,Tbsp,teaspoon,Tablespoon,ounce,oz".split(",");
    ITEMS = "bouillon cube,flour,eggs,flip-flops,flippers,salt,sugar,water,milk,cucumber".split(",");
    NUM_RE = /^[0-9]+(\.[0-9]*)?$/;

    // the parser "API"
    const parseThatShit = (query, caret, callback) => {
        if (query == null || query.trim().length === 0) return;
        if (query.trim() !== query) return;
        const ranges = [];
        const suggestions = [];
        const words = query.split(" ");
        let wIdx = 0;
        let amount = null;
        let unit = null;
        if (NUM_RE.test(words[wIdx])) {
            amount = parseFloat(words[wIdx]);
            if (!isNaN(amount)) {
                ranges.push({
                    start: 0,
                    end: words[wIdx].length,
                    type: "amount",
                });
            }
            wIdx += 1;
        }
        for (let i = wIdx; i < words.length; i++) {
            const w = words[i];
            const sow = words.slice(0, i)
                .reduce((n, w) => n + w.length, i);
            if (amount != null && unit == null) {
                // see about a unit
                let u = UNITS.find(u => u === w);
                if (u != null) {
                    // exact match!
                    unit = u;
                    ranges.push({
                        start: sow,
                        end: sow + u.length,
                        type: "unit",
                    });
                    continue;
                }
                const partials = UNITS.filter(u => u.indexOf(w) === 0)
                partials.forEach(u => {
                    unit = u; // not really true, but whatever
                    suggestions.push({
                        option: u,
                        type: "unit",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + u.length,
                        },
                    });
                });
            }
            let it = ITEMS.find(it => it === w);
            if (it != null) {
                // exact match!
                ranges.push({
                    start: sow,
                    end: sow + it.length,
                    type: "item",
                });
                continue;
            }
            ITEMS.filter(it => it.indexOf(w) === 0)
                .forEach(it => {
                    suggestions.push({
                        option: it,
                        type: "item",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + it.length,
                        },
                    })
                });
            ITEMS.filter(it => it.indexOf(w) !== 0 && it.indexOf(w) > 0)
                .forEach(it => {
                    const idx = it.indexOf(w)
                    suggestions.push({
                        option: {
                            name: it,
                            start: idx,
                            end: idx + w.length,
                        },
                        type: "item",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + it.length,
                        },
                    })
                });
        }
        const response = {
            query,
            caret,
            ranges,
            suggestions,
        }
        setTimeout(() => callback(response), 150 + Math.random() * 300);
    };

    E = document.getElementById("editor");
    A = document.getElementById("autocomplete");
    R = document.getElementById("request");
    P = document.getElementById("parse");
    const empty = node => {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    };
    (function () {
        let query = "";
        let caret = -1;
        reparse = debounce(() => {
            R.innerText = JSON.stringify({query, caret}, null, 3);
            parseThatShit(query, caret, r => {
                if (r.query !== query || r.caret !== caret) return;
                P.innerText = JSON.stringify(r, null, 3);
                // now update!
                let pos = 0
                let segments = []
                r.ranges.sort((a, b) => a.start - b.start)
                    .map((it, i, rs) => {
                        if (i === 0) return it;
                        const prev = rs[i - 1];
                        if (it.start >= prev.end) return it;
                        return {
                            ...it,
                            start: prev.end, // no overlaps!
                        }
                    })
                    .forEach(({start, end, type}) => {
                        if (start > pos) {
                            segments.push(query.substring(pos, start))
                        }
                        segments.push(`<span class="${type}">${query.substring(
                            start,
                            end,
                        )}</span>`)
                        pos = end
                    });
                if (pos < query.length) {
                    segments.push(query.substring(pos))
                }
                E.innerHTML = segments.join("");
                // and auto-complete!
                empty(A);
                r.suggestions
                    .map(s => {
                        const text = typeof s.option === "string"
                            ? s.option
                            : s.option.name;
                        const li = document.createElement("li");
                        li.innerText = text;
                        li.className = s.type;
                        li.addEventListener("click", e => {
                            query = E.innerText.substring(0, s.accept.start)
                                + text
                            + E.innerText.substring(s.accept.end);
                            caret = s.accept.caret;
                            reparse();
                        });
                        A.appendChild(li);
                    })
            });
        }, 150)
        handleUserInteraction = e => {
            const q = E.innerText.replace(/\u00A0/g, " ");
            const c = getCaretCharacterOffsetWithin(E);
            if (caret === c && query === q) return;
            query = q;
            caret = c;
            reparse();
        };
        E.addEventListener("input", handleUserInteraction);
        E.addEventListener("keyup", handleUserInteraction);
        E.addEventListener("mouseup", handleUserInteraction);
    })();
</script>
</body>
</html>
