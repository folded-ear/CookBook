<!doctype html>
<!--suppress HtmlUnknownTarget -->
<html lang="en">
<head>
    <title>Demo</title>
    <style type="text/css">
        #request {
            float: right;
        }
        .amount {
            border-bottom: 1px solid red;
            background-color: #fee;
        }
        .unit {
            border-bottom: 1px solid blue;
            background-color: #eef;
        }
        .item {
            border-bottom: 1px solid green;
            background-color: #efe;
        }
    </style>
</head>
<body>
<div id="editor" contenteditable="true">1.5 cu fl</div>
<ul id="autocomplete"></ul>
<pre id="request"></pre>
<pre id="parse"></pre>
<script type="text/javascript">
    // from https://github.com/JetBrains/ring-ui/blob/master/components/global/dom.js
    function isMounted(node) {
        if (node === document) {
            return true;
        }

        return node instanceof Node && document.documentElement.contains(node.parentNode);
    }

    const rectStub = {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};

    function getRect(node) {
        if (node instanceof Range || isMounted(node)) {
            const {top, right, bottom, left, width, height} = node.getBoundingClientRect();
            return {top, right, bottom, left, width, height};
        } else {
            return Object.assign({}, rectStub);
        }
    }

    // based on https://github.com/JetBrains/ring-ui/blob/master/components/caret/caret.js
    class Caret {
        /**
         * Line endings RegExp
         * @type {RegExp}
         */
        static returnRE = /\r/g;

        /**
         * Line endings normalizer
         * Borrowed from jQuery
         * @see https://github.com/jquery/jquery/blob/master/src/attributes/val.js
         * @param value {*}
         * @return {*}
         */
        static normalizeNewlines(value) {
            return typeof value === 'string' ? value.replace(
                this.returnRE,
                '',
            ) : value;
        }

        constructor(target) {
            this.target = target;
        }

        isContentEditable() {
            return this.target.contentEditable === 'true';
        }

        /**
         * Set focus on target if possible
         */
        focus() {
            if (!document.activeElement || document.activeElement !== this.target) {
                this.target.focus();
            }
        }

        /**
         * Get caret position index
         * @param {Object} [params]
         * @param {boolean} params.avoidFocus
         * @return {number}
         */
        getPosition(params = {}) {
            if (this.isContentEditable()) {
                if (!params.avoidFocus) {
                    this.focus();
                }

                const selection = window.getSelection();

                if (!selection.rangeCount) {
                    return 0;
                }

                const range1 = selection.getRangeAt(0);

                if (range1.startOffset !== range1.endOffset) {
                    return -1;
                }

                const range2 = range1.cloneRange();

                range2.selectNodeContents(this.target);
                range2.setEnd(range1.endContainer, range1.endOffset);

                return range2.toString().length;
            }

            if (this.target.selectionStart !== this.target.selectionEnd) {
                return -1;
            }

            return this.target.selectionStart;
        }

        /**
         * Set caret position index
         * @param  {number} position
         * @return {number}
         */
        setPosition(position) {
            const isContentEditable = this.isContentEditable();
            let correctedPosition;

            if (position === -1) {
                const value = isContentEditable
                    ? this.target.textContent
                    : this.constructor.normalizeNewlines(this.target.value);
                correctedPosition = value.length;
            } else {
                correctedPosition = position;
            }

            if (isContentEditable) {
                this.focus();

                try {
                    window.getSelection()
                        .collapse(
                            this.target.firstChild || this.target,
                            correctedPosition,
                        );
                } catch (e) {
                    // Do nothing
                }

            } else {
                this.target.setSelectionRange(
                    correctedPosition,
                    correctedPosition,
                );
            }

            return correctedPosition;
        }

        /**
         * Get caret position in pixels
         * @return {number}
         */
        getOffset() {
            let offset = 0;
            let range;

            try {
                // Both statements may throw
                range = window.getSelection().getRangeAt(0).cloneRange();
                range.setStart(range.startContainer, range.startOffset - 1);
            } catch (e) {
                return offset;
            }

            if (range && range.endOffset !== 0 && range.toString() !== '') {
                offset =
                    getRect(range).right -
                    getRect(this.target).left -
                    (range.startContainer.offsetLeft || 0);
            }

            return offset;
        }
    }

    // from src/util/debounce.js
    const debounce = (fn, delay = 100) => {
        let timeout = null
        return (...args) => {
            if (timeout != null) {
                clearTimeout(timeout)
            }
            timeout = setTimeout(() => {
                timeout = null
                fn(...args)
            }, delay)
        }
    }

    // the "database"
    UNITS = "cup,tsp,Tbsp,teaspoon,Tablespoon,ounce,oz".split(",");
    ITEMS = "bouillon cube,flour,eggs,flip-flops,flippers,salt,sugar,water,milk,cucumber".split(",");
    NUM_RE = /^[0-9]+(\.[0-9]*)?$/;

    // the parser "API"
    const parseThatShit = (query, caret, callback) => {
        if (query == null || query.trim().length === 0) return;
        if (query.trim() !== query) return;
        const ranges = [];
        const suggestions = [];
        const words = query.split(" ");
        let wIdx = 0;
        let amount = null;
        let unit = null;
        if (NUM_RE.test(words[wIdx])) {
            amount = parseFloat(words[wIdx]);
            if (!isNaN(amount)) {
                ranges.push({
                    start: 0,
                    end: words[wIdx].length,
                    type: "amount",
                });
            }
            wIdx += 1;
        }
        for (let i = wIdx; i < words.length; i++) {
            const w = words[i];
            const sow = words.slice(0, i)
                .reduce((n, w) => n + w.length, i);
            if (amount != null && unit == null) {
                // see about a unit
                let u = UNITS.find(u => u === w);
                if (u != null) {
                    // exact match!
                    unit = u;
                    ranges.push({
                        start: sow,
                        end: sow + u.length,
                        type: "unit",
                    });
                    continue;
                }
                const partials = UNITS.filter(u => u.indexOf(w) === 0)
                partials.forEach(u => {
                    unit = u; // not really true, but whatever
                    suggestions.push({
                        option: u,
                        type: "unit",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + u.length,
                        },
                    });
                });
            }
            let it = ITEMS.find(it => it === w);
            if (it != null) {
                // exact match!
                ranges.push({
                    start: sow,
                    end: sow + it.length,
                    type: "item",
                });
                continue;
            }
            ITEMS.filter(it => it.indexOf(w) === 0)
                .forEach(it => {
                    suggestions.push({
                        option: it,
                        type: "item",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + it.length,
                        },
                    })
                });
            ITEMS.filter(it => it.indexOf(w) !== 0 && it.indexOf(w) > 0)
                .forEach(it => {
                    const idx = it.indexOf(w)
                    suggestions.push({
                        option: {
                            name: it,
                            start: idx,
                            end: idx + w.length,
                        },
                        type: "item",
                        accept: {
                            start: sow,
                            end: sow + w.length,
                            caret: sow + it.length,
                        },
                    })
                });
        }
        const response = {
            query,
            caret,
            ranges,
            suggestions,
        }
        setTimeout(() => callback(response), 150 + Math.random() * 300);
    };

    E = document.getElementById("editor");
    A = document.getElementById("autocomplete");
    R = document.getElementById("request");
    P = document.getElementById("parse");
    const empty = node => {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    };
    (function () {
        let query = "";
        let caret = -1;
        reparse = debounce(() => {
            R.innerText = JSON.stringify({query, caret}, null, 3);
            parseThatShit(query, caret, r => {
                if (r.query !== query || r.caret !== caret) return;
                P.innerText = JSON.stringify(r, null, 3);
                // now update!
                let pos = 0
                let segments = []
                const addChars = (cs, cls) => {
                    const prefix = cls == null
                        ? `<span>`
                        : `<span class="${cls}">`;
                    Array.from(cs).forEach(c =>
                        segments.push(prefix + c + `</span>`));
                }
                r.ranges.sort((a, b) => a.start - b.start)
                    .map((it, i, rs) => {
                        if (i === 0) return it;
                        const prev = rs[i - 1];
                        if (it.start >= prev.end) return it;
                        return {
                            ...it,
                            start: prev.end, // no overlaps!
                        }
                    })
                    .forEach(({start, end, type}) => {
                        if (start > pos) {
                            addChars(query.substring(pos, start))
                        }
                        addChars(query.substring(start, end), type)
                        pos = end
                    });
                if (pos < query.length) {
                    addChars(query.substring(pos))
                }
                const c = new Caret(E);
                const p = c.getPosition();
                const o = c.getOffset();
                E.innerHTML = `<span>${segments.join("")}</span>`;
                console.log("caret a", caret, p, c.getPosition(), o, c.getOffset())
                c.setPosition(caret);
                setTimeout(() =>
                    console.log("      b", caret, p, c.getPosition(), o, c.getOffset()))
                // and auto-complete!
                empty(A);
                r.suggestions
                    .map(s => {
                        const text = typeof s.option === "string"
                            ? s.option
                            : s.option.name;
                        const li = document.createElement("li");
                        li.innerText = text;
                        li.className = s.type;
                        li.addEventListener("click", e => {
                            query = E.innerText.substring(0, s.accept.start)
                                + text
                            + E.innerText.substring(s.accept.end);
                            caret = s.accept.caret;
                            reparse();
                        });
                        A.appendChild(li);
                    })
            });
        }, 150)
        handleUserInteraction = e => {
            const q = E.innerText.replace(/\u00A0/g, " ");
            const c = new Caret(E).getPosition();
            if (caret === c && query === q) return;
            query = q;
            caret = c;
            reparse();
        };
        E.addEventListener("input", handleUserInteraction);
        E.addEventListener("keyup", handleUserInteraction);
        E.addEventListener("mouseup", handleUserInteraction);
    })();
</script>
</body>
</html>
